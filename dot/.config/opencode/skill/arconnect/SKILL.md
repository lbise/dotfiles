---
name: arconnect
description: Create or edit ARConnect inter-core communication interface
---

ARConnect is a configurable hardware block designed to simplify ARC inter-core communication.

## ARConnect Message Definition

This point-to-point interface is used to send messages from one ARC core to another core.

Messages are defined in a YAML file containing two main sections (one per message direction) with the following structure:

- **Section Header:**
  â€¢ Specifies the source (from) and destination (to) cores, the API name, and the starting message ID (`msg_base`).

Example definition snippet:
```
DmTxService:
    from:     sys
    to:       rcu
    api:      arconnect_srv
    msg_base: GENERAL_CHANNEL_MSG_DMTX_BASE_RCU

    - DmTxServiceStart:

    - DmTxServiceConfigureNetwork:
        - { type: uint32_t, name: network_id }
        - { type: uint8_t, name: encryption_enable }
        - { type: uint8_t, name: aes_key, size: 16 }

    - DmTxServiceWriteParametersBatch:
        - { type: uint16_t, name: length, dyn_len: true }
        - { type: uint8_t, name: parameters, size: 12, dyn_pdu: true }

DmTxIndication:
    from:     rcu
    to:       sys
    api:      arconnect_srv
    msg_base: GENERAL_CHANNEL_MSG_DMTX_BASE_SYS

    primitives:
        - DmTxIndStateIdle:

        - DmTxIndBeaconProcessingStart:
            - { type: uint16_t, name: pdu_echo }
            - { type: uint64_t, name: address }
            - { type: bool, name: ack_req }
```

All the necessary code is generated by the andromeda build system when parsing the YAML file for both the source and destination core.

## User Defined

The user must define the following:

* On the source core: A new function wrapping the generated ARConnect function to send the message.

For example
```
void DmTxIndTalkerChange(uint16_t talker_id, bool is_talking, bool mtn_lock_active) {
    sendDmTxIndTalkerChange(talker_id, is_talking, mtn_lock_active);
}
```
* On the destination core: A new function to handle the received message. It is good practice to use the same name as the wrapped function.

For example
```
void DmTxIndTalkerChange(uint16_t talker_id, bool is_talking, bool mtn_lock_active) {
   T_DM_NOARG_INFO("DmTxIndTalkerChange: Received indication");
}
```

* On the destination core: Call the function to handle the message from the callback function.

For example
```
void generalChannelSysDmTxHandler(uint8_t* msg, uint16_t length) {
    uint16_t msg_id = (uint16_t)(msg[0] + (msg[1] << 8));
    switch (msg_id) {
        // Handle message on SYS core
        case ARCONNECT_MSG_ID_DMTXINDTALKERCHANGE: {
            const ARCONNECT_DMTXINDTALKERCHANGE_T* p = (const ARCONNECT_DMTXINDTALKERCHANGE_T*)msg;
            // SYS core has its own implementation of the function to handle the message
            DmTxIndTalkerChange(p->talker_id, p->is_talking, p->mtn_lock_active);
            break;
        }
        default:
            GENERIC_ERROR_PARAMETER("Unhandled message: ", msg_id);
            break;
    }
}
```

## Tips

* In order to determine on which core the code is executed, the easiest way is to look at the path
    * prj/sys for SYS core
    * prj/rcu for RCU core
    * prj/dsp for DSP core
* ARConnect message handlers are configured using the ARConnectSrvAddReceptionCallback function. It links a `msg_base` value from the YAML file to a callback function.

For example, the ARConnect RCU handler for the provided YAML example is generalChannelRcuDmTxHandler
```
ARConnectSrvAddReceptionCallback(ARCONNECT_CORE_ID_SYS, generalChannelRcuDmTxHandler, GENERAL_CHANNEL_MSG_DMTX_BASE_RCU);
```
